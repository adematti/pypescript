"""Generate section names header (for Python, C, C++ and Fortran)."""

import os
import argparse
import yaml

from . import utils


class WriteSections(object):
    """Convenient class to write section header files for Python, C, C++ and Fortran."""

    def __init__(self, filename=None, sections=None, nocopy=None, max_string_length=256):
        """
        Initialise :class:`WriteSections`.

        Parameters
        ----------
        filename : string, default=None
            File name of *yaml* file list sections (and ``nocopy``, see documentation of :meth:`~pypescript.block.DataBlock.copy`)

        sections : list, default=None
            List of sections, if ``filename`` not provided.

        nocopy : list, default=None
            List of sections not to copy (see documentation of :meth:`~pypescript.block.DataBlock.copy`), if ``filename`` not provided.

        max_string_length : int, default=256
            Max length of (section, name) keys, used for Fortran.
        """
        self.sections = sections or []
        self.nocopy = nocopy or {}
        if filename:
            self.read_sections(filename)
        self.filename = filename
        self.max_string_length = max_string_length
        try:
            from pypescript import section_names
            sections = [s for s in dir(section_names) if s != 'nocopy' and not (s.startswith('__') and s.endswith('__'))]
            self.sections = sections + [s for s in self.sections if s not in sections]
            self.nocopy = section_names.nocopy + [s for s in self.nocopy if s not in section_names.nocopy]
        except ImportError:
            # probably pypescript calling...
            pass

    def read_sections(self, filename):
        """Read sections from *yaml* file ``filename``."""
        with open(filename,'r') as file:
            sections = yaml.load(file,Loader=yaml.SafeLoader)
        for section in sections:
            if isinstance(section,str):
                self.sections.append(section)
            else:
                self.nocopy = section['nocopy']

    def header(self, comments='#'):
        """Return header to be added on top of section files."""
        header = ''
        header += '{} This file has been generated by the Python script {}\n'.format(comments,__file__)
        if self.filename: header += '{} Edit the root file {} if necessary.\n'.format(comments,self.filename)
        return header

    def __call__(self, filenames=None):
        """
        Generate section header files for language entries of ``filenames``.

        Parameters
        ----------
        filenames : dict
            Dictionary with (language, filename) mapping.
        """
        filenames = filenames or {}
        for lang,fn in filenames.items():
            func = getattr(self,'write_{}'.format(lang))
            fn = filenames[lang]
            func(fn)

    def write_python(self, filename):
        """Write Python section file to ``filename``."""
        utils.mkdir(filename)
        with open(filename,'w') as file:
            file.write(self.header(comments='#'))
            for section in self.sections:
                file.write("{} = '{}'\n".format(section,section))
            file.write('nocopy = {}'.format(self.nocopy))

    def write_c(self, filename):
        """Write C section header file to ``filename``."""
        utils.mkdir(filename)
        with open(filename,'w') as file:
            file.write(self.header(comments='//'))
            file.write('#define DATABLOCK_MAX_STRING_LENGTH {}\n'.format(self.max_string_length))
            for section in self.sections:
                file.write('#define {}_SECTION "{}"\n'.format(section.upper(),section))

    def write_fortran(self, filename):
        """Write Fortran section header file to ``filename``."""
        utils.mkdir(filename)
        with open(filename,'w') as file:
            file.write(self.header(comments='!'))
            file.write('#define DATABLOCK_MAX_STRING_LENGTH {}\n'.format(self.max_string_length))
            for section in self.sections:
                file.write('#define {}_SECTION "{}"\n'.format(section.upper(),section))


def main(args=None):
    parser = argparse.ArgumentParser(description=WriteSections.__doc__,formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--in-fn', type=str, default='section_names.yaml', help='Input yaml file containing list of section names')
    parser.add_argument('--out-fn', type=str, nargs='*', default=None, help='Output file name')
    parser.add_argument('--lang', type=str, nargs='*', default=['python','c','fortran'], help='Language')
    opt = parser.parse_args(args=args)
    default_filenames = {'python':'section_names.py','c':'src/section_names.h','fortran':'src/section_names.fi'}
    fns = {lang:default_filenames[lang] for lang in opt.lang}
    if opt.out_fn is not None:
        for lang,out_fn in zip(opt.lang,opt.out_fn):
            fns[lang] = out_fn
    ws = WriteSections(opt.in_fn)
    ws(fns)


if __name__ == '__main__':

    main()
