"""Generate section names header (for Python, C, C++ and Fortran)."""

import os
from collections import UserList
import argparse

import yaml

from . import utils


class SectionNames(UserList):
    """Convenient class to write section header files for Python, C, C++ and Fortran."""

    def __init__(self, data=None, max_string_length=256):
        """
        Initialize :class:`SectionNames`.

        Parameters
        ----------
        data : list, default=None
            List of sections.

        max_string_length : int, default=256
            Max length of (section, name) keys, used for Fortran.
        """
        self.data = data or []
        self.max_string_length = max_string_length
        try:
            from pypescript import section_names
            sections = [s for s in dir(section_names) if s != 'nocopy' and not (s.startswith('__') and s.endswith('__'))]
            self.data = sections + [s for s in self.data if s not in sections]
        except ImportError:
            # probably pypescript calling...
            pass

    @classmethod
    def load(cls, filename):
        """Read sections from *yaml* file ``filename``."""
        with open(filename,'r') as file:
            data = yaml.load(file,Loader=yaml.SafeLoader)
        new = cls(data)
        new.filename = filename
        return new

    def header(self, comments='#'):
        """Return header to be added on top of section files."""
        header = ''
        header += '{} This file has been generated by the Python script {}\n'.format(comments,__file__)
        if self.filename: header += '{} Edit the root file {} if necessary.\n'.format(comments,self.filename)
        return header

    def save(self, filename):
        """
        Save section file to ``filename``, with formatting depending on ``filename`` extension:

        - '.py': Python
        - '.h': C
        - '.fi': Fortran

        Parameters
        ----------
        filename : str
            Section file name.
        """
        if filename.endswith('.py'):
            self.save_python(filename)
        elif filename.endswith('.h'):
            self.save_c(filename)
        elif filename.endswith('.fi'):
            self.save_fortran(filename)
        else:
            raise ValueError('Unknown file extension {}.'.format(filename))

    def save_python(self, filename):
        """Write Python section file to ``filename``."""
        utils.mkdir(filename)
        with open(filename,'w') as file:
            file.write(self.header(comments='#'))
            for section in self.data:
                file.write("{} = '{}'\n".format(section,section))

    def save_c(self, filename):
        """Write C section header file to ``filename``."""
        utils.mkdir(filename)
        with open(filename,'w') as file:
            file.write(self.header(comments='//'))
            file.write('#define DATABLOCK_MAX_STRING_LENGTH {}\n'.format(self.max_string_length))
            for section in self.data:
                file.write('#define {}_SECTION "{}"\n'.format(section.upper(),section))

    def save_fortran(self, filename):
        """Write Fortran section header file to ``filename``."""
        utils.mkdir(filename)
        with open(filename,'w') as file:
            file.write(self.header(comments='!'))
            file.write('#define DATABLOCK_MAX_STRING_LENGTH {}\n'.format(self.max_string_length))
            for section in self.data:
                file.write('#define {}_SECTION "{}"\n'.format(section.upper(),section))


def main(args=None):
    parser = argparse.ArgumentParser(description=SectionNames.__doc__,formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--in-fn', type=str, default='section_names.yaml', help='Input yaml file containing list of section names')
    parser.add_argument('--out-fn', type=str, nargs='*', default=None, help='Output file name')
    opt = parser.parse_args(args=args)
    fns = ['section_names.py','section_names.h','section_names.fi']
    if opt.out_fn is None:
        fns = opt.out_fn
    ws = SectionNames.load(opt.in_fn)
    for fn in fns: ws.save(fn)


if __name__ == '__main__':

    main()
